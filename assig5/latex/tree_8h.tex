\section{tree.h File Reference}
\label{tree_8h}\index{tree.h@{tree.h}}
\subsection*{Classes}
\begin{CompactItemize}
\item 
struct \bf{\_\-Tnode}
\end{CompactItemize}
\subsection*{Typedefs}
\begin{CompactItemize}
\item 
typedef \bf{\_\-Tnode} \bf{Tnode}
\end{CompactItemize}
\subsection*{Functions}
\begin{CompactItemize}
\item 
\bf{Tnode} $\ast$ \bf{add\_\-tnode} (\bf{Tnode} $\ast$current\_\-tnode, char $\ast$value)
\item 
void \bf{traverse\-Descending} (\bf{Tnode} $\ast$current\_\-tnode)
\item 
char $\ast$ \bf{convert\-To\-Upper} (char $\ast$str)
\item 
void \bf{free\-Tree} (\bf{Tnode} $\ast$current\_\-tnode)
\end{CompactItemize}


\subsection{Detailed Description}


\subsection{Typedef Documentation}
\index{tree.h@{tree.h}!Tnode@{Tnode}}
\index{Tnode@{Tnode}!tree.h@{tree.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}typedef struct \bf{\_\-Tnode} \bf{Tnode}}\label{tree_8h_9242298e266f76511e0cfefa23a99572}




\subsection{Function Documentation}
\index{tree.h@{tree.h}!add_tnode@{add\_\-tnode}}
\index{add_tnode@{add\_\-tnode}!tree.h@{tree.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}\bf{Tnode}$\ast$ add\_\-tnode (\bf{Tnode} $\ast$ {\em current\_\-tnode}, char $\ast$ {\em value})}\label{tree_8h_4bfce116a958985cbce7618d701f8197}


Add a Tnode to a Tnode on left child if value is alphabetically before or equal or right child if alphabetically after. \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em current\_\-tnode}]The node to attach the new node to.If NULL, will allocate a new Node and return it \item[{\em value}]The value to place in the new node. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]Pointer to the Tnode or NULL if operation failed \end{Desc}
\begin{Desc}
\item[Author:]Steven Kordell \end{Desc}
\index{tree.h@{tree.h}!convertToUpper@{convertToUpper}}
\index{convertToUpper@{convertToUpper}!tree.h@{tree.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}char$\ast$ convert\-To\-Upper (char $\ast$ {\em str})}\label{tree_8h_55598c5fb796fddbe31347850d78d707}


Converts a string to all upper case characters \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em str}]Pointer to the c-style string to convert \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]Pointer to the returned string \end{Desc}
\begin{Desc}
\item[Author:]Steven Kordell \end{Desc}
\index{tree.h@{tree.h}!freeTree@{freeTree}}
\index{freeTree@{freeTree}!tree.h@{tree.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void free\-Tree (\bf{Tnode} $\ast$ {\em current\_\-tnode})}\label{tree_8h_db65a72a7751fd6dd3b6fe1683a50acf}


Frees all the nodes in a tree as well as their contents \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em current\_\-tnode}]The first node to free, all the subnodes will be freed \end{description}
\end{Desc}
\begin{Desc}
\item[Author:]Steven Kordell \end{Desc}
\index{tree.h@{tree.h}!traverseDescending@{traverseDescending}}
\index{traverseDescending@{traverseDescending}!tree.h@{tree.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void traverse\-Descending (\bf{Tnode} $\ast$ {\em current\_\-tnode})}\label{tree_8h_344da03e1ee05b6b54d304448974ab41}


Recursively traverses the tree \char`\"{}in order\char`\"{} but in reverse, that is, visit the right node, then the current node, then the left node \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em current\_\-tnode}]The tnode to visit recursively \end{description}
\end{Desc}
\begin{Desc}
\item[Author:]Steven Kordell \end{Desc}
